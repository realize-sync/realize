---
description: How to work with redb tables and transactions
globs:
alwaysApply: false
---

# Redb Table Management Best Practices

## Core Principle: Open Tables Once Per Transaction

Redb tables can only be opened once per transaction. The recommended pattern is:

1. Open the transaction
2. Open a new scope
3. Open all tables you need
4. Pass tables around to helper functions
5. Close the scope, noting the result
6. Commit the transaction
7. Return the result

## Recommended Pattern

```rust
// Example A: Good pattern
fn do_something() -> Result<(), StorageError> {
    let txn = self.db.begin_write()?;
    let result = {
        let mut my_table = txn.my_table()?;
        let mut my_other_table = txn.my_other_table()?;
        let a = do_a(&mut my_table)?;
        do_b(&mut my_other_table, &my_table, a)?;
        Ok(())
    };
    txn.commit()?;
    result
}
```

## Avoid This Pattern

```rust
// Example B: Problematic pattern
fn do_something() -> Result<(), StorageError> {
    let txn = self.db.begin_write()?;
    let result = {
        let a = do_a(&txn)?;  // Opens table inside do_a
        do_b(&txn, a)?;       // Opens table inside do_b
        Ok(())
    };
    txn.commit()?;
    result
}
```

## Transaction Object Lifetimes and Borrow Checker Issues

### The Problem: Objects Tied to Transactions

Objects returned by transaction methods (like `WritableOpenIndex`, `WritableOpenTree`, etc.) hold mutable references to the transaction. This creates borrow checker issues when you try to commit the transaction while these objects are still alive.

### Common Error: "cannot move out of `txn` because it is borrowed"

```rust
// BAD: This will cause borrow checker errors
fn problematic_pattern() -> Result<(), StorageError> {
    let txn = self.db.begin_write()?;
    let mut index = txn.write_index()?;  // Mutable borrow of txn
    let mut tree = txn.write_tree()?;    // Another mutable borrow of txn
    
    index.add(&mut tree, &path, size, mtime, hash)?;
    
    txn.commit()?;  // Error: txn is still borrowed by index and tree
    Ok(())
}
```

### Solution: Explicit Scoping

Use explicit scope blocks to ensure objects are dropped before committing:

```rust
// GOOD: Explicit scoping to manage object lifetimes
fn correct_pattern() -> Result<(), StorageError> {
    let txn = self.db.begin_write()?;
    {
        let mut index = txn.write_index()?;
        let mut tree = txn.write_tree()?;
        index.add(&mut tree, &path, size, mtime, hash)?;
    } // index and tree are dropped here, releasing their borrows
    
    txn.commit()?;  // Now txn can be committed
    Ok(())
}
```

### Alternative: Single Transaction for Entire Test

For tests, you can often use a single transaction for the entire test
without committing. In that case, call txn.write_tree() and so on at
the very beginning and don't bother with txn.read_tree() and so on
since you can use the tree returned by write_tree to read.

```rust
// GOOD: Single transaction for entire test
#[test]
fn test_operations() -> anyhow::Result<()> {
    let fixture = Fixture::setup()?;
    let txn = fixture.db.begin_write()?;
    let mut index = txn.write_index()?;
    let mut tree = txn.write_tree()?;
    
    // Perform all operations
    index.add(&mut tree, &path, size, mtime, hash)?;
    
    // Verify results using the same transaction and
    // same index and tree.
    assert!(read_index.has(&tree, &path)?);
    
    // No commit needed - transaction will be discarded
    Ok(())
}
```

### Key Principles for Object Lifetimes

1. **Objects from transactions hold borrows**: `WritableOpenIndex`, `WritableOpenTree`, etc. hold `&mut` references to the transaction
2. **Drop objects before committing**: Use explicit scopes to ensure objects are dropped before `txn.commit()`
3. **Single transaction per test**: For tests, often simpler to use one transaction without committing
4. **Avoid multiple table opens**: Never open the same table multiple times within a transaction

## Helper Function Signatures

When writing helper functions that need table access, pass the table references directly:

```rust
// Good: Pass table references
fn add_to_queue_front(
    &self,
    blob_lru_queue_table: &mut redb::Table<'_, u16, Holder<'static, QueueTableEntry>>,
    blob_table: &mut redb::Table<'_, BlobId, Holder<'static, BlobTableEntry>>,
    blob_id: BlobId,
    blob_entry: &mut BlobTableEntry,
) -> Result<(), StorageError> {
    // Work with the tables directly
    let queue_entry = blob_lru_queue_table.get(queue_id)?.unwrap().value().parse()?;
    blob_table.insert(blob_id, Holder::with_content(blob_entry)?)?;
    Ok(())
}

// Avoid: Pass transaction and open tables inside
fn add_to_queue_front(
    &self,
    txn: &ArenaWriteTransaction,  // Don't do this
    blob_id: BlobId,
    blob_entry: &mut BlobTableEntry,
) -> Result<(), StorageError> {
    // This will cause "Table already opened" errors
    let mut queue_table = txn.blob_lru_queue_table()?;
    let mut blob_table = txn.blob_table()?;
    // ...
}
```

## Table Opening Pattern

Always unwrap the `Result` from table opening methods:

```rust
// Good
let mut blob_table = txn.blob_table()?;
let mut queue_table = txn.blob_lru_queue_table()?;

// Avoid
let mut blob_table = txn.blob_table();
let mut queue_table = txn.blob_lru_queue_table();
```

## Common Error: "Table already opened"

This error occurs when you try to open the same table multiple times within a single transaction. Solutions:

1. **Open tables once at the start** and pass references around
2. **Use helper functions** that accept table references instead of transactions
3. **Create separate scopes** for different table operations

## Transaction Lifecycle

```rust
// 1. Begin transaction
let txn = self.db.begin_write()?;

// 2. Open scope for table operations
let result = {
    // 3. Open all needed tables
    let mut table1 = txn.table1()?;
    let mut table2 = txn.table2()?;

    // 4. Pass tables to helper functions
    helper_function(&mut table1, &mut table2)?;

    // 5. Return result from scope
    Ok(())
};

// 6. Commit transaction
txn.commit()?;

// 7. Return final result
result
```

## Reading vs Writing

- **Read transactions**: Use `begin_read()` and tables are read-only
- **Write transactions**: Use `begin_write()` and tables are mutable

```rust
// Read transaction
let txn = self.db.begin_read()?;
let table = txn.my_table()?;  // Read-only
let value = table.get(key)?;

// Write transaction
let txn = self.db.begin_write()?;
let mut table = txn.my_table()?;  // Mutable
table.insert(key, value)?;
```

## Error Handling

Always handle the `Result` from table operations:

```rust
// Good
let entry = table.get(key)?.ok_or(StorageError::NotFound)?;
let value = entry.value().parse()?;

// Avoid
let entry = table.get(key).unwrap();
```

## Table Definition Pattern

Define tables with proper types:

```rust
const MY_TABLE: TableDefinition<KeyType, ValueType> =
    TableDefinition::new("table_name");

// Example
const BLOB_LRU_QUEUE_TABLE: TableDefinition<u16, Holder<'static, QueueTableEntry>> =
    TableDefinition::new("blob.lru_queue");
```

## Integration with Database

Add new tables to the database constructor:

```rust
impl ArenaDatabase {
    pub fn new(db_path: &std::path::Path) -> Result<Self, StorageError> {
        let db = redb::Database::create(db_path)?;

        // Open all tables to ensure they exist
        let txn = db.begin_write()?;
        {
            txn.open_table(MY_TABLE)?;
            txn.open_table(ANOTHER_TABLE)?;
            // ... all tables
        }
        txn.commit()?;

        Ok(Self { inner: db })
    }
}
```

## Testing Pattern

When testing table operations, use the simplified single-transaction pattern:

```rust
#[test]
fn test_table_operations() -> anyhow::Result<()> {
    let fixture = Fixture::setup()?;
    
    // Single transaction for entire test
    let txn = fixture.db.begin_write()?;
    let mut index = txn.write_index()?;
    let mut tree = txn.write_tree()?;
    
    // Perform operations
    index.add(&mut tree, &path, size, mtime, hash)?;
    
    // Verify results using same transaction, index and tree objects.
    assert!(read_index.has(&tree, &path)?);
    
    // No commit needed - transaction will be discarded
    Ok(())
}
```

### Testing Best Practices

1. **Use single transaction per test**: Avoid multiple transaction opens
2. **No explicit commits**: Let the transaction be discarded at test end
3. **Open tables once**: Call `write_index()`, `write_tree()`, etc. only once per test
4. **Use same transaction for verification**: Use read methods on the same transaction for assertions

## Key Takeaways

1. **Open tables once per transaction** - never open the same table twice
2. **Pass table references** to helper functions, not transactions
3. **Use proper scoping** to manage table lifetimes
4. **Always handle Results** from table operations
5. **Follow the pattern**: open transaction → open scope → open tables → pass around → commit
6. **Manage object lifetimes**: Use explicit scopes to drop transaction objects before committing
7. **Single transaction for tests**: Use one transaction per test without explicit commits
4. **Always handle Results** from table operations
5. **Follow the pattern**: open transaction → open scope → open tables → pass around → commit
